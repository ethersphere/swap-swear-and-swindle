{
  "address": "0x989F4d301d7333249362B2484BeE0D501AB01DCa",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_ERC20Address",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "contractAddress",
          "type": "address"
        }
      ],
      "name": "SimpleSwapDeployed",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ERC20Address",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "issuer",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "defaultHardDepositTimeoutDuration",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "salt",
          "type": "bytes32"
        }
      ],
      "name": "deploySimpleSwap",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "deployedContracts",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "master",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xaf0128de8da27d35e66064afd471839ae6a061515ce384f60bc3ffd22d2713bd",
  "receipt": {
    "to": null,
    "from": "0xb1C7F17Ed88189Abf269Bf68A3B2Ed83C5276aAe",
    "contractAddress": "0x989F4d301d7333249362B2484BeE0D501AB01DCa",
    "transactionIndex": 35,
    "gasUsed": "1718730",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x99969a57df70b3137f1d94c9d7335b615c04b05444744715a5c7ff74e5805c97",
    "transactionHash": "0xaf0128de8da27d35e66064afd471839ae6a061515ce384f60bc3ffd22d2713bd",
    "logs": [],
    "blockNumber": 4595399,
    "cumulativeGasUsed": "7675910",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x543dDb01Ba47acB11de34891cD86B675F04840db"
  ],
  "numDeployments": 2,
  "solcInputHash": "91f5cbb4dd7fedf177ab9b96b0007658",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_ERC20Address\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"SimpleSwapDeployed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ERC20Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"issuer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"defaultHardDepositTimeoutDuration\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"salt\",\"type\":\"bytes32\"}],\"name\":\"deploySimpleSwap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"deployedContracts\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"master\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"The Swarm Authors\",\"kind\":\"dev\",\"methods\":{\"deploySimpleSwap(address,uint256,bytes32)\":{\"params\":{\"defaultHardDepositTimeoutDuration\":\"duration in seconds which by default will be used to reduce hardDeposit allocations\",\"issuer\":\"the issuer of cheques for the new chequebook\",\"salt\":\"salt to include in create2 to enable the same address to deploy multiple chequebooks\"}}},\"title\":\"Factory contract for SimpleSwap\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"deploySimpleSwap(address,uint256,bytes32)\":{\"notice\":\"creates a clone of the master SimpleSwap contract\"}},\"notice\":\"This contract deploys SimpleSwap contracts\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SimpleSwapFactory.sol\":\"SimpleSwapFactory\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/proxy/Clones.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x1cc0efb01cbf008b768fd7b334786a6e358809198bb7e67f1c530af4957c6a21\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0x32c202bd28995dd20c4347b7c6467a6d3241c74c8ad3edcbb610cd9205916c45\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\",\"keccak256\":\"0xe9e291de7ffe06e66503c6700b1bb84ff6e0989cbb974653628d8994e7c97f03\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\",\"keccak256\":\"0xfaad496c1c944b6259b7dc70b4865eb1775d6402bc0c81b38a0b24d9f525ae37\",\"license\":\"MIT\"},\"contracts/ERC20SimpleSwap.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity =0.8.19;\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n@title Chequebook contract without waivers\\n@author The Swarm Authors\\n@notice The chequebook contract allows the issuer of the chequebook to send cheques to an unlimited amount of counterparties.\\nFurthermore, solvency can be guaranteed via hardDeposits\\n@dev as an issuer, no cheques should be send if the cumulative worth of a cheques send is above the cumulative worth of all deposits\\nas a beneficiary, we should always take into account the possibility that a cheque bounces (when no hardDeposits are assigned)\\n*/\\ncontract ERC20SimpleSwap {\\n  event ChequeCashed(\\n    address indexed beneficiary,\\n    address indexed recipient,\\n    address indexed caller,\\n    uint totalPayout,\\n    uint cumulativePayout,\\n    uint callerPayout\\n  );\\n  event ChequeBounced();\\n  event HardDepositAmountChanged(address indexed beneficiary, uint amount);\\n  event HardDepositDecreasePrepared(address indexed beneficiary, uint decreaseAmount);\\n  event HardDepositTimeoutChanged(address indexed beneficiary, uint timeout);\\n  event Withdraw(uint amount);\\n\\n  uint public defaultHardDepositTimeout;\\n  /* structure to keep track of the hard deposits (on-chain guarantee of solvency) per beneficiary*/\\n  struct HardDeposit {\\n    uint amount; /* hard deposit amount allocated */\\n    uint decreaseAmount; /* decreaseAmount substranced from amount when decrease is requested */\\n    uint timeout; /* issuer has to wait timeout seconds to decrease hardDeposit, 0 implies applying defaultHardDepositTimeout */\\n    uint canBeDecreasedAt; /* point in time after which harddeposit can be decreased*/\\n  }\\n\\n  struct EIP712Domain {\\n    string name;\\n    string version;\\n    uint256 chainId;\\n  }\\n\\n  bytes32 public constant EIP712DOMAIN_TYPEHASH = keccak256(\\n    \\\"EIP712Domain(string name,string version,uint256 chainId)\\\"\\n  );\\n  bytes32 public constant CHEQUE_TYPEHASH = keccak256(\\n    \\\"Cheque(address chequebook,address beneficiary,uint256 cumulativePayout)\\\"\\n  );\\n  bytes32 public constant CASHOUT_TYPEHASH = keccak256(\\n    \\\"Cashout(address chequebook,address sender,uint256 requestPayout,address recipient,uint256 callerPayout)\\\"\\n  );\\n  bytes32 public constant CUSTOMDECREASETIMEOUT_TYPEHASH = keccak256(\\n    \\\"CustomDecreaseTimeout(address chequebook,address beneficiary,uint256 decreaseTimeout)\\\"\\n  );\\n\\n  // the EIP712 domain this contract uses\\n  function domain() internal view returns (EIP712Domain memory) {    \\n    return EIP712Domain({\\n      name: \\\"Chequebook\\\",\\n      version: \\\"1.0\\\",\\n      chainId: block.chainid\\n    });\\n  }\\n\\n  // compute the EIP712 domain separator. this cannot be constant because it depends on chainId\\n  function domainSeparator(EIP712Domain memory eip712Domain) internal pure returns (bytes32) {\\n    return keccak256(abi.encode(\\n        EIP712DOMAIN_TYPEHASH,\\n        keccak256(bytes(eip712Domain.name)),\\n        keccak256(bytes(eip712Domain.version)),\\n        eip712Domain.chainId\\n    ));\\n  }\\n\\n  // recover a signature with the EIP712 signing scheme\\n  function recoverEIP712(bytes32 hash, bytes memory sig) internal view returns (address) {\\n    bytes32 digest = keccak256(abi.encodePacked(\\n        \\\"\\\\x19\\\\x01\\\",\\n        domainSeparator(domain()),\\n        hash\\n    ));\\n    return ECDSA.recover(digest, sig);\\n  }\\n\\n  /* The token against which this chequebook writes cheques */\\n  IERC20 public token;\\n  /* associates every beneficiary with how much has been paid out to them */\\n  mapping (address => uint) public paidOut;\\n  /* total amount paid out */\\n  uint public totalPaidOut;\\n  /* associates every beneficiary with their HardDeposit */\\n  mapping (address => HardDeposit) public hardDeposits;\\n  /* sum of all hard deposits */\\n  uint public totalHardDeposit;\\n  /* issuer of the contract, set at construction */\\n  address public issuer;\\n  /* indicates wether a cheque bounced in the past */\\n  bool public bounced;\\n\\n  /**\\n  @notice sets the issuer, token and the defaultHardDepositTimeout. can only be called once.\\n  @param _issuer the issuer of cheques from this chequebook (needed as an argument for \\\"Setting up a chequebook as a payment\\\").\\n  _issuer must be an Externally Owned Account, or it must support calling the function cashCheque\\n  @param _token the token this chequebook uses\\n  @param _defaultHardDepositTimeout duration in seconds which by default will be used to reduce hardDeposit allocations\\n  */\\n  function init(address _issuer, address _token, uint _defaultHardDepositTimeout) public {\\n    require(_issuer != address(0), \\\"invalid issuer\\\");\\n    require(issuer == address(0), \\\"already initialized\\\");\\n    issuer = _issuer;\\n    token = IERC20(_token);\\n    defaultHardDepositTimeout = _defaultHardDepositTimeout;\\n  }\\n\\n  /// @return the balance of the chequebook\\n  function balance() public view returns(uint) {\\n    return token.balanceOf(address(this));\\n  }\\n  /// @return the part of the balance that is not covered by hard deposits\\n  function liquidBalance() public view returns(uint) {\\n    return balance() - totalHardDeposit;\\n  }\\n\\n  /// @return the part of the balance available for a specific beneficiary\\n  function liquidBalanceFor(address beneficiary) public view returns(uint) {\\n    return liquidBalance() + hardDeposits[beneficiary].amount;\\n  }\\n  /**\\n  @dev internal function responsible for checking the issuerSignature, updating hardDeposit balances and doing transfers.\\n  Called by cashCheque and cashChequeBeneficary\\n  @param beneficiary the beneficiary to which cheques were assigned. Beneficiary must be an Externally Owned Account\\n  @param recipient receives the differences between cumulativePayment and what was already paid-out to the beneficiary minus callerPayout\\n  @param cumulativePayout cumulative amount of cheques assigned to beneficiary\\n  @param issuerSig if issuer is not the sender, issuer must have given explicit approval on the cumulativePayout to the beneficiary\\n  */\\n  function _cashChequeInternal(\\n    address beneficiary,\\n    address recipient,\\n    uint cumulativePayout,\\n    uint callerPayout,\\n    bytes memory issuerSig\\n  ) internal {\\n    /* The issuer must have given explicit approval to the cumulativePayout, either by being the caller or by signature*/\\n    if (msg.sender != issuer) {\\n      require(issuer == recoverEIP712(chequeHash(address(this), beneficiary, cumulativePayout), issuerSig),\\n      \\\"invalid issuer signature\\\");\\n    }\\n    /* the requestPayout is the amount requested for payment processing */\\n    uint requestPayout = cumulativePayout - paidOut[beneficiary];\\n    /* calculates acutal payout */\\n    uint totalPayout = Math.min(requestPayout, liquidBalanceFor(beneficiary));\\n    /* calculates hard-deposit usage */\\n    uint hardDepositUsage = Math.min(totalPayout, hardDeposits[beneficiary].amount);\\n    require(totalPayout >= callerPayout, \\\"SimpleSwap: cannot pay caller\\\");\\n    /* if there are some of the hard deposit used, update hardDeposits*/\\n    if (hardDepositUsage != 0) {\\n      hardDeposits[beneficiary].amount = hardDeposits[beneficiary].amount - hardDepositUsage;\\n      totalHardDeposit = totalHardDeposit - hardDepositUsage;\\n    }\\n    /* increase the stored paidOut amount to avoid double payout */\\n    paidOut[beneficiary] = paidOut[beneficiary] + totalPayout;\\n    totalPaidOut = totalPaidOut + totalPayout;\\n\\n    /* let the world know that the issuer has over-promised on outstanding cheques */\\n    if (requestPayout != totalPayout) {\\n      bounced = true;\\n      emit ChequeBounced();\\n    }\\n\\n    if (callerPayout != 0) {\\n    /* do a transfer to the caller if specified*/\\n      require(token.transfer(msg.sender, callerPayout), \\\"transfer failed\\\");\\n      /* do the actual payment */\\n      require(token.transfer(recipient, totalPayout - callerPayout), \\\"transfer failed\\\");\\n    } else {\\n      /* do the actual payment */\\n      require(token.transfer(recipient, totalPayout), \\\"transfer failed\\\");\\n    }\\n\\n    emit ChequeCashed(beneficiary, recipient, msg.sender, totalPayout, cumulativePayout, callerPayout);\\n  }\\n  /**\\n  @notice cash a cheque of the beneficiary by a non-beneficiary and reward the sender for doing so with callerPayout\\n  @dev a beneficiary must be able to generate signatures (be an Externally Owned Account) to make use of this feature\\n  @param beneficiary the beneficiary to which cheques were assigned. Beneficiary must be an Externally Owned Account\\n  @param recipient receives the differences between cumulativePayment and what was already paid-out to the beneficiary minus callerPayout\\n  @param cumulativePayout cumulative amount of cheques assigned to beneficiary\\n  @param beneficiarySig beneficiary must have given explicit approval for cashing out the cumulativePayout by the sender and sending the callerPayout\\n  @param issuerSig if issuer is not the sender, issuer must have given explicit approval on the cumulativePayout to the beneficiary\\n  @param callerPayout when beneficiary does not have ether yet, he can incentivize other people to cash cheques with help of callerPayout\\n  @param issuerSig if issuer is not the sender, issuer must have given explicit approval on the cumulativePayout to the beneficiary\\n  */\\n  function cashCheque(\\n    address beneficiary,\\n    address recipient,\\n    uint cumulativePayout,\\n    bytes memory beneficiarySig,\\n    uint256 callerPayout,\\n    bytes memory issuerSig\\n  ) public {\\n    require(\\n      beneficiary == recoverEIP712(\\n        cashOutHash(\\n          address(this),\\n          msg.sender,\\n          cumulativePayout,\\n          recipient,\\n          callerPayout\\n        ), beneficiarySig\\n      ), \\\"invalid beneficiary signature\\\");\\n    _cashChequeInternal(beneficiary, recipient, cumulativePayout, callerPayout, issuerSig);\\n  }\\n\\n  /**\\n  @notice cash a cheque as beneficiary\\n  @param recipient receives the differences between cumulativePayment and what was already paid-out to the beneficiary minus callerPayout\\n  @param cumulativePayout amount requested to pay out\\n  @param issuerSig issuer must have given explicit approval on the cumulativePayout to the beneficiary\\n  */\\n  function cashChequeBeneficiary(address recipient, uint cumulativePayout, bytes memory issuerSig) public {\\n    _cashChequeInternal(msg.sender, recipient, cumulativePayout, 0, issuerSig);\\n  }\\n\\n  /**\\n  @notice prepare to decrease the hard deposit\\n  @dev decreasing hardDeposits must be done in two steps to allow beneficiaries to cash any uncashed cheques (and make use of the assgined hard-deposits)\\n  @param beneficiary beneficiary whose hard deposit should be decreased\\n  @param decreaseAmount amount that the deposit is supposed to be decreased by\\n  */\\n  function prepareDecreaseHardDeposit(address beneficiary, uint decreaseAmount) public {\\n    require(msg.sender == issuer, \\\"SimpleSwap: not issuer\\\");\\n    HardDeposit storage hardDeposit = hardDeposits[beneficiary];\\n    /* cannot decrease it by more than the deposit */\\n    require(decreaseAmount <= hardDeposit.amount, \\\"hard deposit not sufficient\\\");\\n    // if hardDeposit.timeout was never set, apply defaultHardDepositTimeout\\n    uint timeout = hardDeposit.timeout == 0 ? defaultHardDepositTimeout : hardDeposit.timeout;\\n    hardDeposit.canBeDecreasedAt = block.timestamp + timeout;\\n    hardDeposit.decreaseAmount = decreaseAmount;\\n    emit HardDepositDecreasePrepared(beneficiary, decreaseAmount);\\n  }\\n\\n  /**\\n  @notice decrease the hard deposit after waiting the necesary amount of time since prepareDecreaseHardDeposit was called\\n  @param beneficiary beneficiary whose hard deposit should be decreased\\n  */\\n  function decreaseHardDeposit(address beneficiary) public {\\n    HardDeposit storage hardDeposit = hardDeposits[beneficiary];\\n    require(block.timestamp >= hardDeposit.canBeDecreasedAt && hardDeposit.canBeDecreasedAt != 0, \\\"deposit not yet timed out\\\");\\n    /* this throws if decreaseAmount > amount */\\n    //TODO: if there is a cash-out in between prepareDecreaseHardDeposit and decreaseHardDeposit, decreaseHardDeposit will throw and reducing hard-deposits is impossible.\\n    hardDeposit.amount = hardDeposit.amount - hardDeposit.decreaseAmount;\\n    /* reset the canBeDecreasedAt to avoid a double decrease */\\n    hardDeposit.canBeDecreasedAt = 0;\\n    /* keep totalDeposit in sync */\\n    totalHardDeposit = totalHardDeposit - hardDeposit.decreaseAmount;\\n    emit HardDepositAmountChanged(beneficiary, hardDeposit.amount);\\n  }\\n\\n  /**\\n  @notice increase the hard deposit\\n  @param beneficiary beneficiary whose hard deposit should be decreased\\n  @param amount the new hard deposit\\n  */\\n  function increaseHardDeposit(address beneficiary, uint amount) public {\\n    require(msg.sender == issuer, \\\"SimpleSwap: not issuer\\\");\\n    /* ensure hard deposits don't exceed the global balance */\\n    require(totalHardDeposit + amount <= balance(), \\\"hard deposit exceeds balance\\\");\\n\\n    HardDeposit storage hardDeposit = hardDeposits[beneficiary];\\n    hardDeposit.amount = hardDeposit.amount + amount;\\n    // we don't explicitely set hardDepositTimout, as zero means using defaultHardDepositTimeout\\n    totalHardDeposit = totalHardDeposit + amount;\\n    /* disable any pending decrease */\\n    hardDeposit.canBeDecreasedAt = 0;\\n    emit HardDepositAmountChanged(beneficiary, hardDeposit.amount);\\n  }\\n\\n  /**\\n  @notice allows for setting a custom hardDepositDecreaseTimeout per beneficiary\\n  @dev this is required when solvency must be guaranteed for a period longer than the defaultHardDepositDecreaseTimeout\\n  @param beneficiary beneficiary whose hard deposit decreaseTimeout must be changed\\n  @param hardDepositTimeout new hardDeposit.timeout for beneficiary\\n  @param beneficiarySig beneficiary must give explicit approval by giving his signature on the new decreaseTimeout\\n  */\\n  function setCustomHardDepositTimeout(\\n    address beneficiary,\\n    uint hardDepositTimeout,\\n    bytes memory beneficiarySig\\n  ) public {\\n    require(msg.sender == issuer, \\\"not issuer\\\");\\n    require(\\n      beneficiary == recoverEIP712(customDecreaseTimeoutHash(address(this), beneficiary, hardDepositTimeout), beneficiarySig),\\n      \\\"invalid beneficiary signature\\\"\\n    );\\n    hardDeposits[beneficiary].timeout = hardDepositTimeout;\\n    emit HardDepositTimeoutChanged(beneficiary, hardDepositTimeout);\\n  }\\n\\n  /// @notice withdraw ether\\n  /// @param amount amount to withdraw\\n  // solhint-disable-next-line no-simple-event-func-name\\n  function withdraw(uint amount) public {\\n    /* only issuer can do this */\\n    require(msg.sender == issuer, \\\"not issuer\\\");\\n    /* ensure we don't take anything from the hard deposit */\\n    require(amount <= liquidBalance(), \\\"liquidBalance not sufficient\\\");\\n    require(token.transfer(issuer, amount), \\\"transfer failed\\\");\\n  }\\n\\n  function chequeHash(address chequebook, address beneficiary, uint cumulativePayout)\\n  internal pure returns (bytes32) {\\n    return keccak256(abi.encode(\\n      CHEQUE_TYPEHASH,\\n      chequebook,\\n      beneficiary,\\n      cumulativePayout\\n    ));\\n  }  \\n\\n  function cashOutHash(address chequebook, address sender, uint requestPayout, address recipient, uint callerPayout)\\n  internal pure returns (bytes32) {\\n    return keccak256(abi.encode(\\n      CASHOUT_TYPEHASH,\\n      chequebook,\\n      sender,\\n      requestPayout,\\n      recipient,\\n      callerPayout\\n    ));\\n  }\\n\\n  function customDecreaseTimeoutHash(address chequebook, address beneficiary, uint decreaseTimeout)\\n  internal pure returns (bytes32) {\\n    return keccak256(abi.encode(\\n      CUSTOMDECREASETIMEOUT_TYPEHASH,\\n      chequebook,\\n      beneficiary,\\n      decreaseTimeout\\n    ));\\n  }\\n}\\n\\n\\n\",\"keccak256\":\"0x2f079c4708c4df6932964be5c2d4a549079ea9a181ad8886cc17975bbd49aceb\",\"license\":\"BSD-3-Clause\"},\"contracts/SimpleSwapFactory.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\npragma solidity =0.8.19;\\nimport \\\"./ERC20SimpleSwap.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\n\\n/**\\n@title Factory contract for SimpleSwap\\n@author The Swarm Authors\\n@notice This contract deploys SimpleSwap contracts\\n*/\\ncontract SimpleSwapFactory {\\n\\n  /* event fired on every new SimpleSwap deployment */\\n  event SimpleSwapDeployed(address contractAddress);\\n\\n  /* mapping to keep track of which contracts were deployed by this factory */\\n  mapping (address => bool) public deployedContracts;\\n\\n  /* address of the ERC20-token, to be used by the to-be-deployed chequebooks */\\n  address public ERC20Address;\\n  /* address of the code contract from which all chequebooks are cloned */\\n  address public master;\\n\\n  constructor(address _ERC20Address) {\\n    ERC20Address = _ERC20Address;\\n    ERC20SimpleSwap _master = new ERC20SimpleSwap();\\n    // set the issuer of the master contract to prevent misuse\\n    _master.init(address(1), address(0), 0);\\n    master = address(_master);\\n  }\\n  /**\\n  @notice creates a clone of the master SimpleSwap contract\\n  @param issuer the issuer of cheques for the new chequebook\\n  @param defaultHardDepositTimeoutDuration duration in seconds which by default will be used to reduce hardDeposit allocations\\n  @param salt salt to include in create2 to enable the same address to deploy multiple chequebooks\\n  */\\n  function deploySimpleSwap(address issuer, uint defaultHardDepositTimeoutDuration, bytes32 salt)\\n  public returns (address) {    \\n    address contractAddress = Clones.cloneDeterministic(master, keccak256(abi.encode(msg.sender, salt)));\\n    ERC20SimpleSwap(contractAddress).init(issuer, ERC20Address, defaultHardDepositTimeoutDuration);\\n    deployedContracts[contractAddress] = true;\\n    emit SimpleSwapDeployed(contractAddress);\\n    return contractAddress;\\n  }\\n}\",\"keccak256\":\"0x116cd540139d505ea4461cd19722ffede13929b9e5a751573200f591e4dff32b\",\"license\":\"BSD-3-Clause\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051611d90380380611d9083398101604081905261002f91610116565b600180546001600160a01b0319166001600160a01b03831617905560405160009061005990610109565b604051809103906000f080158015610075573d6000803e3d6000fd5b506040516343431f6360e11b81526001600482015260006024820181905260448201529091506001600160a01b038216906386863ec690606401600060405180830381600087803b1580156100c957600080fd5b505af11580156100dd573d6000803e3d6000fd5b5050600280546001600160a01b0319166001600160a01b03949094169390931790925550610146915050565b6118ff8061049183390190565b60006020828403121561012857600080fd5b81516001600160a01b038116811461013f57600080fd5b9392505050565b61033c806101556000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806315efd8a714610051578063a6021ace14610081578063c70242ad14610094578063ee97f7f3146100c7575b600080fd5b61006461005f3660046102b1565b6100da565b6040516001600160a01b0390911681526020015b60405180910390f35b600154610064906001600160a01b031681565b6100b76100a23660046102e4565b60006020819052908152604090205460ff1681565b6040519015158152602001610078565b600254610064906001600160a01b031681565b60025460408051336020820152908101839052600091829161011e916001600160a01b031690606001604051602081830303815290604052805190602001206101eb565b6001546040516343431f6360e11b81526001600160a01b0388811660048301529182166024820152604481018790529192508216906386863ec690606401600060405180830381600087803b15801561017657600080fd5b505af115801561018a573d6000803e3d6000fd5b505050506001600160a01b03811660008181526020818152604091829020805460ff1916600117905590519182527fc0ffc525a1c7689549d7f79b49eca900e61ac49b43d977f680bcc3b36224c004910160405180910390a1949350505050565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528360601b60148201526e5af43d82803e903d91602b57fd5bf360881b6028820152826037826000f59150506001600160a01b03811661028f5760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b80356001600160a01b03811681146102ac57600080fd5b919050565b6000806000606084860312156102c657600080fd5b6102cf84610295565b95602085013595506040909401359392505050565b6000602082840312156102f657600080fd5b6102ff82610295565b939250505056fea26469706673582212203f76e42322bce6a35f6ef0357cad6785061a54bbbe936b5cc1a425f13408ffbc64736f6c63430008130033608060405234801561001057600080fd5b506118df806100206000396000f3fe608060405234801561001057600080fd5b506004361061014d5760003560e01c8063946f46a2116100c3578063b7ec1a331161007c578063b7ec1a331461033f578063c49f91d314610347578063c76a4d311461036e578063d4c9a8e814610381578063e0bcf13a14610394578063fc0c546a1461039d57600080fd5b8063946f46a214610271578063b6343b0d14610284578063b648b417146102d9578063b69ef8a8146102fd578063b777035014610305578063b79989071461031857600080fd5b80631d143848116101155780631d143848146101c65780632e1a7d4d146101f1578063338f3fed14610204578063488b017c1461021757806381f03fcb1461023e57806386863ec61461025e57600080fd5b80630d5f26591461015257806312101021146101675780631357e1dc1461018357806315c3343f1461018c5780631633fb1d146101b3575b600080fd5b61016561016036600461166b565b6103b0565b005b61017060005481565b6040519081526020015b60405180910390f35b61017060035481565b6101707f48ebe6deff4a5ee645c01506a026031e2a945d6f41f1f4e5098ad65347492c1281565b6101656101c13660046116c2565b6103c3565b6006546101d9906001600160a01b031681565b6040516001600160a01b03909116815260200161017a565b6101656101ff366004611759565b6104b5565b610165610212366004611772565b6105eb565b6101707f7d824962dd0f01520922ea1766c987b1db570cd5db90bdba5ccf5e320607950281565b61017061024c36600461179c565b60026020526000908152604090205481565b61016561026c3660046117b7565b610727565b61016561027f36600461179c565b6107f2565b6102b961029236600461179c565b60046020526000908152604090208054600182015460028301546003909301549192909184565b60408051948552602085019390935291830152606082015260800161017a565b6006546102ed90600160a01b900460ff1681565b604051901515815260200161017a565b6101706108e0565b610165610313366004611772565b610952565b6101707fe95f353750f192082df064ca5142d3a2d6f0bef0f3ffad66d80d8af86b7a749a81565b610170610a86565b6101707fc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e81565b61017061037c36600461179c565b610a9d565b61016561038f36600461166b565b610ace565b61017060055481565b6001546101d9906001600160a01b031681565b6103be338484600085610bd9565b505050565b604080517f7d824962dd0f01520922ea1766c987b1db570cd5db90bdba5ccf5e32060795026020808301919091523082840152336060830152608082018790526001600160a01b03881660a083015260c08083018690528351808403909101815260e0909201909252805191012061043b9084611023565b6001600160a01b0316866001600160a01b0316146104a05760405162461bcd60e51b815260206004820152601d60248201527f696e76616c69642062656e6566696369617279207369676e617475726500000060448201526064015b60405180910390fd5b6104ad8686868585610bd9565b505050505050565b6006546001600160a01b031633146104fc5760405162461bcd60e51b815260206004820152600a6024820152693737ba1034b9b9bab2b960b11b6044820152606401610497565b610504610a86565b8111156105535760405162461bcd60e51b815260206004820152601c60248201527f6c697175696442616c616e6365206e6f742073756666696369656e74000000006044820152606401610497565b60015460065460405163a9059cbb60e01b81526001600160a01b0391821660048201526024810184905291169063a9059cbb906044016020604051808303816000875af11580156105a8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105cc91906117f3565b6105e85760405162461bcd60e51b815260040161049790611815565b50565b6006546001600160a01b0316331461063e5760405162461bcd60e51b815260206004820152601660248201527529b4b6b83632a9bbb0b81d103737ba1034b9b9bab2b960511b6044820152606401610497565b6106466108e0565b816005546106549190611854565b11156106a25760405162461bcd60e51b815260206004820152601c60248201527f68617264206465706f73697420657863656564732062616c616e6365000000006044820152606401610497565b6001600160a01b038216600090815260046020526040902080546106c7908390611854565b81556005546106d7908390611854565b6005556000600382015580546040519081526001600160a01b038416907f2506c43272ded05d095b91dbba876e66e46888157d3e078db5691496e96c5fad906020015b60405180910390a2505050565b6001600160a01b03831661076e5760405162461bcd60e51b815260206004820152600e60248201526d34b73b30b634b21034b9b9bab2b960911b6044820152606401610497565b6006546001600160a01b0316156107bd5760405162461bcd60e51b8152602060048201526013602482015272185b1c9958591e481a5b9a5d1a585b1a5e9959606a1b6044820152606401610497565b600680546001600160a01b039485166001600160a01b0319918216179091556001805493909416921691909117909155600055565b6001600160a01b0381166000908152600460205260409020600381015442108015906108215750600381015415155b61086d5760405162461bcd60e51b815260206004820152601960248201527f6465706f736974206e6f74207965742074696d6564206f7574000000000000006044820152606401610497565b6001810154815461087e9190611867565b81556000600382015560018101546005546108999190611867565b60055580546040519081526001600160a01b038316907f2506c43272ded05d095b91dbba876e66e46888157d3e078db5691496e96c5fad9060200160405180910390a25050565b6001546040516370a0823160e01b81523060048201526000916001600160a01b0316906370a0823190602401602060405180830381865afa158015610929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094d919061187a565b905090565b6006546001600160a01b031633146109a55760405162461bcd60e51b815260206004820152601660248201527529b4b6b83632a9bbb0b81d103737ba1034b9b9bab2b960511b6044820152606401610497565b6001600160a01b03821660009081526004602052604090208054821115610a0e5760405162461bcd60e51b815260206004820152601b60248201527f68617264206465706f736974206e6f742073756666696369656e7400000000006044820152606401610497565b60008160020154600014610a26578160020154610a2a565b6000545b9050610a368142611854565b6003830155600182018390556040518381526001600160a01b038516907fc8305077b495025ec4c1d977b176a762c350bb18cad4666ce1ee85c32b78698a9060200160405180910390a250505050565b6000600554610a936108e0565b61094d9190611867565b6001600160a01b038116600090815260046020526040812054610abe610a86565b610ac89190611854565b92915050565b6006546001600160a01b03163314610b155760405162461bcd60e51b815260206004820152600a6024820152693737ba1034b9b9bab2b960b11b6044820152606401610497565b610b29610b233085856110f3565b82611023565b6001600160a01b0316836001600160a01b031614610b895760405162461bcd60e51b815260206004820152601d60248201527f696e76616c69642062656e6566696369617279207369676e61747572650000006044820152606401610497565b6001600160a01b03831660008181526004602052604090819020600201849055517f7b816003a769eb718bd9c66bdbd2dd5827da3f92bc6645276876bd7957b08cf09061071a9085815260200190565b6006546001600160a01b03163314610c5657610bf9610b23308786611164565b6006546001600160a01b03908116911614610c565760405162461bcd60e51b815260206004820152601860248201527f696e76616c696420697373756572207369676e617475726500000000000000006044820152606401610497565b6001600160a01b038516600090815260026020526040812054610c799085611867565b90506000610c8f82610c8a89610a9d565b6111ba565b6001600160a01b03881660009081526004602052604081205491925090610cb79083906111ba565b905084821015610d095760405162461bcd60e51b815260206004820152601d60248201527f53696d706c65537761703a2063616e6e6f74207061792063616c6c65720000006044820152606401610497565b8015610d5e576001600160a01b038816600090815260046020526040902054610d33908290611867565b6001600160a01b038916600090815260046020526040902055600554610d5a908290611867565b6005555b6001600160a01b038816600090815260026020526040902054610d82908390611854565b6001600160a01b038916600090815260026020526040902055600354610da9908390611854565b600355828214610df0576006805460ff60a01b1916600160a01b1790556040517f3f4449c047e11092ec54dc0751b6b4817a9162745de856c893a26e611d18ffc490600090a15b8415610f335760015460405163a9059cbb60e01b8152336004820152602481018790526001600160a01b039091169063a9059cbb906044016020604051808303816000875af1158015610e47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e6b91906117f3565b610e875760405162461bcd60e51b815260040161049790611815565b6001546001600160a01b031663a9059cbb88610ea38886611867565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af1158015610eee573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1291906117f3565b610f2e5760405162461bcd60e51b815260040161049790611815565b610fc6565b60015460405163a9059cbb60e01b81526001600160a01b038981166004830152602482018590529091169063a9059cbb906044016020604051808303816000875af1158015610f86573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610faa91906117f3565b610fc65760405162461bcd60e51b815260040161049790611815565b604080518381526020810188905290810186905233906001600160a01b0389811691908b16907f950494fc3642fae5221b6c32e0e45765c95ebb382a04a71b160db0843e74c99f9060600160405180910390a45050505050505050565b6000806110a96110316111d2565b805180516020918201208183015180519083012060408085015181517fc2f8787176b8ac6bf7215b4adcc1e069bf4ab82d9ab1df05a57a91d425935b6e95810195909552908401929092526060830152608082015260009060a001604051602081830303815290604052805190602001209050919050565b60405161190160f01b60208201526022810191909152604281018590526062016040516020818303038152906040528051906020012090506110eb8184611248565b949350505050565b604080517fe95f353750f192082df064ca5142d3a2d6f0bef0f3ffad66d80d8af86b7a749a60208201526001600160a01b038086169282019290925290831660608201526080810182905260009060a0015b6040516020818303038152906040528051906020012090509392505050565b604080517f48ebe6deff4a5ee645c01506a026031e2a945d6f41f1f4e5098ad65347492c1260208201526001600160a01b038086169282019290925290831660608201526080810182905260009060a001611145565b60008183106111c957816111cb565b825b9392505050565b6111f660405180606001604052806060815260200160608152602001600081525090565b506040805160a081018252600a6060820190815269436865717565626f6f6b60b01b608083015281528151808301835260038152620312e360ec1b602082810191909152820152469181019190915290565b6000806000611257858561126c565b91509150611264816112da565b509392505050565b60008082516041036112a25760208301516040840151606085015160001a61129687828585611490565b945094505050506112d3565b82516040036112cb57602083015160408401516112c086838361157d565b9350935050506112d3565b506000905060025b9250929050565b60008160048111156112ee576112ee611893565b036112f65750565b600181600481111561130a5761130a611893565b036113575760405162461bcd60e51b815260206004820152601860248201527f45434453413a20696e76616c6964207369676e617475726500000000000000006044820152606401610497565b600281600481111561136b5761136b611893565b036113b85760405162461bcd60e51b815260206004820152601f60248201527f45434453413a20696e76616c6964207369676e6174757265206c656e677468006044820152606401610497565b60038160048111156113cc576113cc611893565b036114245760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202773272076616c604482015261756560f01b6064820152608401610497565b600481600481111561143857611438611893565b036105e85760405162461bcd60e51b815260206004820152602260248201527f45434453413a20696e76616c6964207369676e6174757265202776272076616c604482015261756560f01b6064820152608401610497565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08311156114c75750600090506003611574565b8460ff16601b141580156114df57508460ff16601c14155b156114f05750600090506004611574565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa158015611544573d6000803e3d6000fd5b5050604051601f1901519150506001600160a01b03811661156d57600060019250925050611574565b9150600090505b94509492505050565b6000806001600160ff1b03831660ff84901c601b0161159e87828885611490565b935093505050935093915050565b80356001600160a01b03811681146115c357600080fd5b919050565b634e487b7160e01b600052604160045260246000fd5b600082601f8301126115ef57600080fd5b813567ffffffffffffffff8082111561160a5761160a6115c8565b604051601f8301601f19908116603f01168101908282118183101715611632576116326115c8565b8160405283815286602085880101111561164b57600080fd5b836020870160208301376000602085830101528094505050505092915050565b60008060006060848603121561168057600080fd5b611689846115ac565b925060208401359150604084013567ffffffffffffffff8111156116ac57600080fd5b6116b8868287016115de565b9150509250925092565b60008060008060008060c087890312156116db57600080fd5b6116e4876115ac565b95506116f2602088016115ac565b945060408701359350606087013567ffffffffffffffff8082111561171657600080fd5b6117228a838b016115de565b94506080890135935060a089013591508082111561173f57600080fd5b5061174c89828a016115de565b9150509295509295509295565b60006020828403121561176b57600080fd5b5035919050565b6000806040838503121561178557600080fd5b61178e836115ac565b946020939093013593505050565b6000602082840312156117ae57600080fd5b6111cb826115ac565b6000806000606084860312156117cc57600080fd5b6117d5846115ac565b92506117e3602085016115ac565b9150604084013590509250925092565b60006020828403121561180557600080fd5b815180151581146111cb57600080fd5b6020808252600f908201526e1d1c985b9cd9995c8819985a5b1959608a1b604082015260600190565b634e487b7160e01b600052601160045260246000fd5b80820180821115610ac857610ac861183e565b81810381811115610ac857610ac861183e565b60006020828403121561188c57600080fd5b5051919050565b634e487b7160e01b600052602160045260246000fdfea2646970667358221220e7a6fb62d773ba85f997655dd2fe29f2d8180eac7cdbc266d60046566974e58264736f6c63430008130033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806315efd8a714610051578063a6021ace14610081578063c70242ad14610094578063ee97f7f3146100c7575b600080fd5b61006461005f3660046102b1565b6100da565b6040516001600160a01b0390911681526020015b60405180910390f35b600154610064906001600160a01b031681565b6100b76100a23660046102e4565b60006020819052908152604090205460ff1681565b6040519015158152602001610078565b600254610064906001600160a01b031681565b60025460408051336020820152908101839052600091829161011e916001600160a01b031690606001604051602081830303815290604052805190602001206101eb565b6001546040516343431f6360e11b81526001600160a01b0388811660048301529182166024820152604481018790529192508216906386863ec690606401600060405180830381600087803b15801561017657600080fd5b505af115801561018a573d6000803e3d6000fd5b505050506001600160a01b03811660008181526020818152604091829020805460ff1916600117905590519182527fc0ffc525a1c7689549d7f79b49eca900e61ac49b43d977f680bcc3b36224c004910160405180910390a1949350505050565b6000604051733d602d80600a3d3981f3363d3d373d3d3d363d7360601b81528360601b60148201526e5af43d82803e903d91602b57fd5bf360881b6028820152826037826000f59150506001600160a01b03811661028f5760405162461bcd60e51b815260206004820152601760248201527f455243313136373a2063726561746532206661696c6564000000000000000000604482015260640160405180910390fd5b92915050565b80356001600160a01b03811681146102ac57600080fd5b919050565b6000806000606084860312156102c657600080fd5b6102cf84610295565b95602085013595506040909401359392505050565b6000602082840312156102f657600080fd5b6102ff82610295565b939250505056fea26469706673582212203f76e42322bce6a35f6ef0357cad6785061a54bbbe936b5cc1a425f13408ffbc64736f6c63430008130033",
  "devdoc": {
    "author": "The Swarm Authors",
    "kind": "dev",
    "methods": {
      "deploySimpleSwap(address,uint256,bytes32)": {
        "params": {
          "defaultHardDepositTimeoutDuration": "duration in seconds which by default will be used to reduce hardDeposit allocations",
          "issuer": "the issuer of cheques for the new chequebook",
          "salt": "salt to include in create2 to enable the same address to deploy multiple chequebooks"
        }
      }
    },
    "title": "Factory contract for SimpleSwap",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "deploySimpleSwap(address,uint256,bytes32)": {
        "notice": "creates a clone of the master SimpleSwap contract"
      }
    },
    "notice": "This contract deploys SimpleSwap contracts",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3775,
        "contract": "contracts/SimpleSwapFactory.sol:SimpleSwapFactory",
        "label": "deployedContracts",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 3777,
        "contract": "contracts/SimpleSwapFactory.sol:SimpleSwapFactory",
        "label": "ERC20Address",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 3779,
        "contract": "contracts/SimpleSwapFactory.sol:SimpleSwapFactory",
        "label": "master",
        "offset": 0,
        "slot": "2",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}